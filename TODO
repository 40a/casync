* verify
* diff
* fuse mount logic
* save/restore btrfs file/subvol flags
* save/restore hardlinks?
* check fs features when restoring
* encryption: aes256 of rotating hash function + HMAC for identifying chunks + individually encrypted chunks
* hardlink/reflink from seed
* exclude patterns
* permit shifting UID/GIDs
* delete old files in destination after sync
* build seed while extracting
* optionally make seeds persistent
* stop at mount points
* acquire gpg signature along with caidx/caibx/catar
* coalesce index frames sent over protocol
* rework uploading via ssh to use seed instead of cache store for providing chunks to server
* casync-http: parallel http GETs
* casync-http: try all configured stores one after the other before sending MISSING
* add support for compressed index files and archive files
* replace adler32 by something better (buzhash)
* define mime types for our files
* define http-based url protocol prefix for caibx+caidx
* support accessing base trees through native protocol
* implicitly generate index + chunks when accessing base trees or archives through native protocol
* rework caindex to read multiple chunks per read (use reallocbuffer like elsewhere)
* permit 511 (or 4095?) redundant NUL bytes at the end of archive and index files, so that they could in theory stored on block devices
* archive digest can't sanely process subdirectories right now, since it will include trailing data that belongs to the next objects already
* when listing archive contents, seek over payload
* when restoring file objects, do so atomically by using temporary file and rename (except: directories)
* decoder: rework seek by file offset to match seek by path semantics of async CA_DECODER_SEEK events
* propagate feature flags into index, and then into seed
* seed: cache GOODBYE name table data so that we can regenerate the right bits when needed
* decoder: count how many bytes on disk we saved due to sparse files, and due to reflinks
